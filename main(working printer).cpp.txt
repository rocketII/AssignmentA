/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * File:   main.cpp
 * Author: bps
 *
 * Created on den 1 mars 2016, 08:00
 */

#include <cstdlib>
#include <sstream>
#include <string>
#include <iostream>
using namespace std;
/*
string printDataStringStream();
int main(int argc, char** argv)
{

    cout << printDataStringStream() << "that's all folks!";
    return 0;
}
string printDataStringStream()
{
    stringstream ss;
    int arr[2]={110,220};
    std::string arr2[]={"first loop", "second loop"};
    for(int i=0; i < 2;i++)
    {
        ss << arr2[i] << arr[i]<<endl;
    }
    return ss.str();
}

*/























///////////////////////////////////////////
/////////try something
///////////////////////////////////////////


class CellPhone
{
private:
    string model;
    int InStock;
    int price;

public:

    CellPhone();
    CellPhone(string model, int InStock, int price);
    ~CellPhone();
    void setModel(string model);
    void setStock(int currentStock);
    void setPrice(int price);
    string getModel(void) const;
    int getStock(void) const;
    int getPrice(void) const;
    string toString() const;


};

class CellPhoneHandler
{
private:
    CellPhone **bridge;
    int sizeArray, numberOfPhones;
    string *myStringPtr;
    bool myStringPtrUsed;
public:
    CellPhoneHandler();

    CellPhoneHandler(int size);

    ~CellPhoneHandler();


    CellPhoneHandler(const CellPhoneHandler &origin);

    CellPhoneHandler& operator=(const CellPhoneHandler &origin);
	//*& hela pekaren ej kopia *
    void AllTheDataStored2Array(string*& myStringPtr);

    int howManyPhones(void)const;

    bool addPhone(string model, int InStock, int price);

    string showAllPhones(void)const;

    string showAllPhonesInStockLessthanUnits(int units)const;

};
////////////////////////////////////////////
/////////////cellphone def
////////////////////////////////////////////
CellPhone::CellPhone()
{
    this->model="Default phone";
    this->InStock=1;
    this->price=3000;
	
}
CellPhone::CellPhone(string model, int stock, int price)
{
    this->model=model;
    this->InStock=stock;
    this->price=price;
}

CellPhone::~CellPhone()
{
    ;
}
void CellPhone::setModel(std::string model)
{
    this->model=model;
}
void CellPhone::setStock(int currentStock)
{
    this->InStock=currentStock;
}
void CellPhone::setPrice(int price)
{

    this->price=price;
}
std::string CellPhone::getModel(void)const
{
    return this->model;

}
int CellPhone::getStock(void)const
{
    return this->InStock;
}
int CellPhone::getPrice(void)const
{
    return this->price;
}
string CellPhone::toString()const
{
    std::stringstream ss;
    ss << "model name: "<< this->getModel() <<" there's" << this->getStock() << "left in stock" << "They costs"<< this->getPrice() << " each"<<endl;
    return ss.str();
}

////////////////////////////////////
//////////cellphonehandler definitions
////////////////////////////////////

CellPhoneHandler::CellPhoneHandler()
{
    //create default array with pointers to default objects of CellPhoneClass
    this->bridge = new CellPhone*[5];
	this->sizeArray = 5;
	this->numberOfPhones=0;
    this->myStringPtr=NULL;



}

CellPhoneHandler::CellPhoneHandler(int size)
{
    //create default array with pointers to default objects of CellPhoneClass
    this->sizeArray=size;
    this->bridge = new CellPhone*[this->sizeArray];
    this->myStringPtr=NULL;



}

CellPhoneHandler::~CellPhoneHandler()
{
    if(this->bridge != NULL)
    {
        ///This time we only destroy those which we added not array capacity. Sorry OS for last time :s
        for(int i=0; i < this->howManyPhones(); i++)
        {
            delete this->bridge[i];
        }
        delete [] this->bridge;

    }
    if(this->myStringPtrUsed == true)
    {
        delete []  this->myStringPtr;
    }
}

//creates an array of pointers to objects.
//And there are two arrays not related which is the case with default copy construct.
CellPhoneHandler::CellPhoneHandler(const CellPhoneHandler &origin)
{

    this->sizeArray=origin.sizeArray;

    this->bridge = new CellPhone*[origin.sizeArray];

    for(int i =0; this->howManyPhones(); i++)
    {
        this->bridge[i]=new CellPhone(*origin.bridge[i]);

    }
}

CellPhoneHandler& CellPhoneHandler::operator =(const CellPhoneHandler& origin)
{
    //orgin and this pointer cannot have the same address if the assigment event are to occour.
    if(this != &origin)
    {
        //deep copy.

        //make sure target and Source has the same size.
        this->sizeArray = origin.sizeArray;

        //for(int i=0; i < origin.howManyPhones(); i++)
        //{
            //empty target on object pointer by freeing memory on the heap.
        for(int i=0; i < this->howManyPhones(); i++)
        {
        delete this->bridge[i];
        }
        //Dealloc memory of array.

        delete [] this->bridge; //you can create freeMemory() to save work.

        //the target then creates an new array filled with object pointers!!!

        this->bridge= new CellPhone*[origin.sizeArray] ;              //makecopy()

        //ofc! We must fill the array with pointer objects that orgin has.

        for(int i =0; i < this->howManyPhones(); i++)
        {
            this->bridge[i]=new CellPhone(*origin.bridge[i]);
        }

        //}
    }
    return *this;
}
//An array with enoug space for all the data are sent here and filled with each object data in CellPhone Class.
////////////////////////////////////////////////////////////////////////////////////
//a.k.a. fillitUp().
///////////////////////////////////////////////////////////////////////////////////

void CellPhoneHandler::AllTheDataStored2Array(string *&myStringPtr)
{
    if(myStringPtr == NULL)
    {
        myStringPtr = new string[this->howManyPhones()];
    }
    else
    {
        delete myStringPtr;
        myStringPtr = nullptr;
    }


    this->myStringPtrUsed=true;


    for(int i = 0; i < this->howManyPhones(); i++)
    {
        myStringPtr[i] = this->bridge[i]->toString();
    }
}

int CellPhoneHandler::howManyPhones( void)const
{
    //current keep track of cellphones

    return this->numberOfPhones;

    //myString is an pointer to the first element in the array.

}
bool CellPhoneHandler::addPhone(string model, int InStock, int price)
{
    bool flag = false;

    if( this->howManyPhones() < this->sizeArray)
    {
        this->bridge[this->numberOfPhones++] = new CellPhone(model, InStock, price);

        flag=true;


    }

    if(this->howManyPhones() > this->sizeArray-1)
    {
        CellPhone **tmp_bridge;

        tmp_bridge = new CellPhone*[this->sizeArray+5];

        //for(int i=0; i < this->sizeArray; i++)
        for(int i=0; i < this->howManyPhones(); i++)
        {
            tmp_bridge[i] = this->bridge[i];
        }

        //for(int i=0; i < this->sizeArray; i++)
        //only delete the known number.
        for(int i=0; i < this->howManyPhones(); i++)
        {
            delete this->bridge[i];
        }
        delete [] bridge;

        this->bridge = new CellPhone*[sizeArray+5];
        //for(int i=0; i < this->sizeArray; i++)
        //only fetch the known number.
        for(int i=0; i < this->howManyPhones(); i++)
        {
            this->bridge[i] = tmp_bridge[i];
        }

        this->sizeArray+=5;


    }

    return flag;
}

//Using phone obj tostring() and the user granted StringArray that should have the correct number of phones. We fill it and can later be used.
string CellPhoneHandler::showAllPhones(void)const
{
    stringstream dd;
    for(int i =0; i < this->howManyPhones(); i++)
    {
        //
        /*	How to solve this? Help!!
         * ../InlämningA/CellPhoneHandler.cpp:
         * In member function ‘void CellPhoneHandler::showAllPhones(std::string&) const’:
         * ../InlämningA/CellPhoneHandler.cpp:379:20: error:
         *  cannot convert ‘std::string {aka std::basic_string<char>}’ to
         *  ‘char’ in assignment myStringArray[i] = this->bridge[i]->toString();
         */
        dd << this->bridge[i]->toString();
    }
    return dd.str();
}


string CellPhoneHandler::showAllPhonesInStockLessthanUnits(int units)const
{
    stringstream ss;

    for(int i=0; i < this->sizeArray; i++ )
    {
        if(this->bridge[i]->getStock() < units )
        {
            ss << this->bridge[i]->getModel() << "has only" << this->bridge[i]->getStock() << "left!" << endl;
        }

    }

    return ss.str();
}

int main()
{
	string *myStringPtrArr1= nullptr;
    CellPhoneHandler myPhoneStorage1;
    myPhoneStorage1.addPhone("mamsung", 30, 1500);
    myPhoneStorage1.addPhone("lamsung", 300, 2000);
    myPhoneStorage1.addPhone("kamsung", 3000, 2500);
    myPhoneStorage1.AllTheDataStored2Array(myStringPtrArr1);
    for(int i=0; i < 3; i++)
    {
        cout << myStringPtrArr1[i];
    }
    cout <<"\nthe end"<<endl;
	getchar();
    return 0;
}
